# 유효 범위

프로그램이 커지면 여러 이유로 충돌 발생

=> 유효범위, 스코프(Scope)로 해결



## 출현 배경

```java
public class ScopeDemo {
	static void a() {
		int i = 0;
	}
	
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			a();
			System.out.println(i);
		}
	}

}
```

i가 a 메소드 안에서 선언됐으므로 반복문의 변수에 영향 X (메소드 안에서만 유효)

=> 유효 범위(Scope)



## 다양한 유효범위들

```java
public class ScopeDemo2 {
	static int i;
	
	static void a() {
		i = 0;
	}
	
	public static void main(String[] args) {
		for (i = 0; i< 5; i++) {
			a();
			System.out.println(i);
		}
	}
}
```

 => 무한 반복

i = 0으로 계속 바뀜

int i라고 하면 제대로 실행 됨 why?

=> int i 하면 변수를 새로 선언, 중괄호 안에서만 유효한 범위 선언



## 정적인 유효범위(static, lexical scope)

```java
package org.opentutorials.javatutorials.scope;

public class ScopeDemo6 {
	static void a() {
		int i = 10;
		b();
	}
	
	static void b() {
		System.out.println(i);
	}
	
	public static void main(String[] args) {
		int i = 1;
		a();
	}
}
```

누가 b를 호출했는지 상관 없이 지역적인 것이 전역적인 것보다 우선순위가 높다

메소드 내(b)에서 지역변수가 존재하지 않는다면 그 메소드가 소속된 클래스의 전역변수를 사용

<=> 동적인 유효범위(dynamic  scope)



## 인스턴스 유효범위

```java
class C {
	int v = 10;
	
	void m() {
		int v = 20;
		System.out.println(v);
		System.out.println(this.v);
	}
}

public class ScopeDemo7 {
	
	public static void main(String[] args) {
		C c1 = new C();
		c1.m();
	}
}
```

this를 사용해 메소드 m에서 인스턴스 변수 v에 접근

this : 인스턴스 자신을 의미



## 교훈

유효범위 : 지역변수, 지역변수 나눠서 좀 더 관리 편리하도록

객체지향 프로그래밍에서도 가급적이면 전역변수 사용 자제하는 것이 좋음